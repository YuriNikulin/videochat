Реализация видеочата работает на локальном сервере на платформе node.js. Используемые node.js фреймворки (express.js, socket.io) установлены с помощью пакетного менеджера npm.

Код для серверной части приложения содержится в файле index.js. Для запуска локального сервера необходим обычный unix-терминал (в Windows в качестве терминала можно использовать приложение git bash) и node.js, установленный в системе. Необходимо в консоли перейти в корневую папку приложения и выполнить команду node index.js, после чего выполнится код в файле index.js, и сервер будет запущен. Приложение будет доступно в браузере по локальному адресу localhost:3000, для других устройств адрес будет иметь вид IP СЕРВЕРА:3000. Во время тестирования приложения использовался компьютер с IP 192.168.1.68, результирующий адрес был 192.168.1.68:3000.
Ниже будет представлен поверхностный обзор файла index.js
Код начинается с объявления глобальных переменных, соответствующих используемым фреймворкам и модулям. После того, как объект фреймворка добавляется в глобальную видимость, становится возможным использовать методы этого объекта.

var express = require('express');
var path = require('path');
var app = express();
var http = require('http').Server(app);
var io = require('socket.io')(http);

С помощью path.resolve переменной publicPath присваивается абсолютный путь к приложению. Для того, чтобы локальный сервер мог выдавать пользователям статичные html, css и javascript файлы, используется функция промежуточной обработки express.static.  

var publicPath = path.resolve(__dirname, './');
app.use(express.static(publicPath));
app.get('/', function(req, res){
    res.sendFile('socket.html', {root: publicPath});
});

На этом код, отвечающий за работу локального сервера, заканчивается. Начинается работа с серверной частью socket.io. Обрабатываются различные события, вызываемые действиями пользователей.
Пользователь, перейдя по адресу приложения, видит страницу index.html. Элементы страницы стилизованы с помощью css, для простой интерфейсной логики используется jquery, находящийся в файлах script.js и ui.js, которые подключаются в index.html. При нажатии на кнопку Create a new room появляется поле ввода для имени комнаты. Предполагается, что после ввода имени комнаты пользователь нажмёт Create. Произойдёт вызов функции createRoom. Она возьмёт введённое имя комнаты и сохранит его в cookie пользователя. Кроме того, в данной функции будет осуществлена проверка на пустоту поля ввода. 

function createRoom(container) {
	var input = container.find('.create-room__input'),
		roomName = input.val();
	if (!roomName) {
		showLocalError(container, 'You need to enter a name for your room');
		return false;
	}
	document.cookie = 'room=' + roomName;
	redirectToChat();
}

После вызывается функция redirectToChat, которая перенаправляет пользователя на страницу с видеочатом (chat.html). В chat.html имеется два video HTML-элемента. В один из них, с идентификатором localVideo, будет транслироваться видео с собственной камеры клиента (при условии, что у него есть камера, и что браузер дал приложению доступ к камере, что происходит не всегда, например, браузер Google Chrome запрещает доступ к камере для сайтов без https). В элемент с идентификатором remoteVideo будет транслироваться видео с камеры собеседника, когда собеседник будет найден. На странице chat.html подключаются скрипты socket.io.js (для клиентской реализации socket.io), adapter.js, main.js - для работы с WebRTC. Ключевой скрипт будет выполняться в main.js.
В main.js задаются начальные значения переменных, необходимые для логики приложения. В переменной pcConfig указывается STUN сервер:

var pcConfig = {
  'iceServers': [{
    'urls': 'stun:stun.l.google.com:19302'
  }]
};

В переменной sdpConstraints указывается, что при обмене SDP (Session Description Protocol) пиры буду обмениваться видео и аудио.

var sdpConstraints = {
    offerToReceiveAudio: true,
    offerToReceiveVideo: true
};

Из cookie с помощью простого регулярного выражения берётся имя комнаты (введённое ранее на странице index.html). Имя комнаты показывается на странице. Если имени нет, показывается ошибка.

var room;
var roomTitle = $('.room-name');
var roomName = document.cookie.match( /room=(.*)/);
if (roomName) {
  roomName = roomName[1];
  roomTitle.html(roomTitle.html() + ' ' + roomName);
}

else {
  isError = true;
  showLocalError(roomTitle, 'You haven\'t selected a room name, you can return to homepage and choose one in order to create a new room or join existing', 'pos-relative');
}

Происходит инициализация socket.io

var socket = io.connect();

Тригеррится событие main check. Его главной целью является обмен имени комнаты между двумя пользователями. 

socket.emit('main check', room);

В серверной части это событие обрабатывается и тригеррится событие main check answer.

socket.on('main check', function(room) {
	socket.broadcast.emit('main check answer', room);
})

В клиентской части main check answer обрабатывается.

socket.on('main check answer', function(remoteRoom) {
  if (remoteRoom == room) {
    isStarted = false;
    isChannelReady = true;
    var remoteContainer = $('.videos__remote');
    remoteContainer.find('.videos__text-container').remove();
    remoteContainer.append('<div class="videos__text-container"><span class="videos__span videos__text">Some user is calling you</span><span class="videos__text ui videos__btn js--accept-call">Accept</span></div>');
    setTimeout(function() {
      remoteContainer.find('.videos__text-container').addClass('shown');
    }, 50);
    remoteContainer.find('.js--accept-call').on('click', function() {
      isHostAgreed = true;
      remoteContainer.find('.videos__text-container').remove();
      socket.emit('host is agreed', room);
    })
  } else {
    isStarted = true;
    isChannelReady = false;
  }
})

Таким образом, если второй пользователь хочет подключиться к существующей комнате, создатель комнаты видит уведомление, что к нему хотят подлючиться. Так как в данный момент переменная remoteRoom == undefined (не определена, так как второй пользователь не передал название своей комнаты), то условие remoteRoom == room не выполняется. Данное условие выполнится, когда к созданной комнате захочет подключиться второй пользователь.
Далее происходит захват изображения с локальной камеры с помощью getUserMedia.

var localVideo = document.querySelector('#localVideo');
navigator.mediaDevices.getUserMedia({
  audio: true,
  video: true
})
.then(gotStream)
.catch(function(e) {
  alert('Error: ' + e.name);
});

function gotStream(stream) {
  if (isError) {
    return false;
  }
  
  localVideo.src = window.URL.createObjectURL(stream);
  localStream = stream;
  sendMessage('got user media');
  if (isInitiator) {
    maybeStart();
  }
}

Помимо транслирования медиапотока в localVideo эта функция передаёт на сервер сообщение got user media, а сервер транслирует данное сообщение обратно другим клиентам. На клиентской стороне получение данного сообщения инициирует вызов функции maybeStart, которая является главным инициатором установления связи между пирами.

function maybeStart() {
    if (!isStarted && typeof localStream !== 'undefined' && isChannelReady) {
    createPeerConnection();
    pc.addStream(localStream);
    isStarted = true;
    console.log('isInitiator', isInitiator);
      doCall();
  }
}

Ранее в обработчике main check answer переменной isStarted было присвоено значение true, поэтому условие не сработает.
Выполнение JavaScript у пользователя, создавшего комнату, заканчивается, и ему остаётся ждать, когда в его комнату подключится другой пользователь.
Допустим, подключается второй пользователь. Он вводит имя комнаты, и в это время в комнате с таким же именем первый пользователь ждёт собеседника. Второй пользователь перенаправляется на chat.html, где захватывается изображение с его камеры, при этом на сервер отправляется сообщение got user media. В это время у первого пользователя срабатывает событие main check answer, в этот раз remoteRoom == room (второй пользователь отправил первому "правильное" имя комнаты), поэтому код внутри условия выполняется. Переменная isStarted получает значение false. Первый пользователь получает от сервера сообщение got user media, вызывается функция maybeStart. В этот раз условие срабатывает, и тело функции выполняется. Вызывается функция createPeerConnection.

function createPeerConnection() {
  try {
    pc = new RTCPeerConnection(null);
    pc.onicecandidate = handleIceCandidate;
    pc.onaddstream = handleRemoteStreamAdded;
    pc.onremovestream = handleRemoteStreamRemoved;
  } catch (e) {
    console.log('Failed to create PeerConnection, exception: ' + e.message);
    alert('Cannot create RTCPeerConnection object.');
    return;
  }
}

Создаётся новый объект RTCPPeerConnection. Добавляются обработчики для событий icecandidate - чтобы пиры обменивались кандидатами, addstream - чтобы транслировать полученный от собеседника медиапоток на video элемент с идентификатором remoteVideo, removestream - чтобы остановить трансляцию при остановке сеанса. 
После cretePeerConnection вызывается функция doCall. 

function doCall() {
  pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
}

